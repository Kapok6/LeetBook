# 1. k2

大纲及占比：

1. 编程语言 55%
2. 安全规范 18%
3. 通用规范 15%
4. 调试与定位
5. 测试开发与执行
6. 编译与构建

## 1.1. 编程语言

【大纲】
- 熟练掌握JavaScript的高级特性：对象、闭包、function、继承等

- 熟练掌握ES5、ES6的高级特性：Proxy、Promise、Generator函数等

- 熟练掌握函数式编程：纯函数、柯里化、高阶函数、组合等概念

- 熟练掌握模块导入和导出的用法、区别和原理

- 熟练掌握计时器的使用场景和用法

- 熟练掌握正则表达式的基础用法，能对字符串实现简单的正则匹配

- 掌握BOM常用API（window/ Navigator/ Location/ History）的用法

- 掌握客户端存储(localStorage/sessionStorage/cookies等)的区别和用法

- 掌握浏览器缓存、HTTP状态码、方法、响应头的基础知识和设置方法。

- 了解V8引擎和Blink渲染引擎基础知识（渲染机制、页面加载解析过程）

- 掌握常用的JS设计模式、掌握基础的代码重构方法论。

  

  1、掌握JavaScript基本语法和基本特性：数组、字符串、循环、数学运算、作用域、上下文、函数、变量、运算符、事件等
  2、熟悉JS对象，掌握JS的面向对象编程方法：class基本语法&类继承、对象方法等
  3、掌握JavaScript的高级特性：对象、闭包、function对象、继承等，掌握ES5、ES6的高级特性：Proxy、Promise、Generator函数等
  4、熟悉掌握BOM（浏览器对象模型，提供与浏览器交互的方法和接口）、DOM（文档对象模型，提供访问和操作网页内容的方法和接口）相关编程操作
  5、了解HTTP服务基础概念，如路由、代理、缓存
  6、熟练掌握JavaScript主流框架的原理、差异
  7、掌握HTML/CSS的基础特性和语法，如表单元素、超链接等常用标签，浮动、定位等页面布局。

### 1.1.1. 语法
#### 1.1.1.1. 数组操作

1. 替换/添加 `arr.splice(start,[count,newVal])`：通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会**改变原数组**。

   1. `count`省略：删除，删除start及其之后的元素，逗号可省可不省
   2. `count=0`：添加，在`start`处添加`neVal`
   3. `count!=0`：替换，用`neVal`替换从`start`开始，`count`个元素

   - start为负，则从倒数第start个开始

   ```javascript
   let arr = [3,4,5,6];
   console.log(arr.splice(-1,),arr); // [6], [3,4,5]
   
   const months = ['Jan', 'March', 'April', 'June'];
   months.splice(3, 1, 'May');
   console.log(months); // ["Jan", "March", "April", "May"]
   ```

2. **切片** `arr.slice(start,[end])`：返回一个新的数组对象，由 `begin` 和 `end` 决定的**浅拷贝**（左闭右开）。**不会改变原数组**。

   ```javascript
   let a = [{key:1},{key:2},{key:3}];
   let b = a.slice(1,2); // [{key:2}]
   a[1].key = 'new key'; // a:[{key:1},{key:new key},{key:3}]
   console.log(b);  // [{key:new key}] 浅拷贝
   ```
   
3. 移除 `arr.shif()`：**移除**数组的第一个元素，常和push一起实现队列，此方法**修改原数组**，并且返回第一个元素。

   ```javascript
   let arr = [1,2,3];
   first = arr.shif();
   console.log(first,arr) // [2,3]
   ```

4. 插入 `arr.unshif()`：在数组的第一个元素前**增加**一个元素，此方法**修改原数组**，并且返回新数组长度。

   - `call`：将字符串转换为数组，然后将数组最前方插入一个字符串，最后输出出来。

   ```javascript
   let arr = [1,2,3];
   console.log(arr.unshif(4,5)); // 5
   console.log(arr) //  [4,5,1,2,3];
   
   function arrFun(arg) {
     let args = Array.prototype.slice.call(arg);
     args.unshift('your app');
     console.log.apply(console,args) // your app j a v a
   }
   arrFun('java');
   ```

5. 转换  `map`：用户提供一个映射方法，然后将原数组通过映射方法生成**新数组**，映射方法包含三个参数：当前值、索引、原数组，map方法除了支持回调函数以外，还可以传一个值作为回调函数的this。

   - parseInt默认接受两个参数，第一个为转换的值，第二个为转换的进制。（若进制为零，则返回原数；若非零，且进制<转换的值，则返回NaN。）
   - map第一个为当前值，第二个为索引。

```javascript
   let arr = [1,4,9,16];
   let m1 = arr.map(x=>x*2);
   console.log(m1); // [2,8,18,32]
   
   let narr = ['1','2','3'].map(parseInt);
   // parseInt(1,0) = 1; paseInt(2,1) = NAN; 以此类推
   console.log(narr); // [ 1, NaN, NaN ]
```

6. 转换 `from`：方法可以将类似数组的对象转换为一个数组，第一个参数传待转换数组，后面两个参数与map方法保持一致。

   ```javascript
   console.log(Array.from('fo')); // [ 'f', 'o']
   console.log(Array.from([1,2],x=>2*x)); // [ 2, 4]
   Proxy、Promise、Generator函数等
   ```
   
7. 查找 `every/some/filter/find`

   1. ``arr.every(func)`：返回true/false，判断数组中每个元素是否满足条件。
   2. `arr.some(func)`：返回true/false，判断数组中是否存在满足条件的值。
   3. `arr.filter(func)`：返回符和条件的新数组，无则返回[]。
   4. `arr.find(func)`：返回第一个满足条件的元素，无则返回undefined。
   5. `arr.includes(el)`：返回true/false。（优点：(1)可判断NaN元素(2)返回值语义化，无需再处理。缺点：无法获取元素的下标）
   6. `arr.indexOf(el)`：返回的是元素的所在下标，如果不存在则返回-1。（优点：可以得到元素下标。缺点：(1)无法判断是否有NaN的元素(2)返回的值不够语义化，需要我们进行处理）

8. 累加器`arr.reduce(func,[curVal, curIndex])`：

   ```javascript
   let arr = [1,2,3,4];
   arr.reduce((tol,cur)=>tol+cur); // 10
   arr.reduce((tol,cur)=>tol+cur, 5); // 15
   ```

9. 排序 `arr.sort(func)`：按指定规则排序，默认用第一个字符的ascll(数字排序，默认非大小顺序)。会**改变原数组**。

   ```javascript
   let arr = [1,30,4,21,1000];
   // asCII顺序
   arr.sort();// [1,1000,21,30,4]
   // 数值升序
   arr.sort((a,b)=>a-b); // [ 1, 1000, 21, 30, 4 ]
   // 数值降序
   arr.sort((a,b)=>b-a);// [ 1000, 30, 21, 4, 1 ]
   ```

10. 扁平化 `arr.flat(numb)`：ES6，将嵌套的数组变成一维数组，返回新数组。（规则：（1）默认numb=1，只扁平化一层；若不管深度，完全拉平，可设置`numb=Infinity`。（2）若有空值，跳过）。

11. map+扁平化 `arr.flatMap(func)`，相当于`map(func)+flat(1)`

    ```javascript
    let arr = [[2, 4], 6,9,[3, 6], [4, 8]].flatMap(x=>x*2);
    log(arr); // [ NaN, 12, 18, NaN, NaN ], 注意 []*2会返回NaN
    
    let arr1 = ["it's Sunny in", "", "California"];
    arr1.map(x => x.split(" "));//[["it's","Sunny","in"],[""],["California"]]
    arr1.flatMap(x=>x.split(' ')); //["it's","Sunny","in", "", "California"]
    ```

12. 原地拷贝`arr.copyWithin(target[, start[, end]])`：浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。（注：start,end省略，默认start=0）

    ```javascript
    let arr = [4,5,6,7];
    log(arr.copyWithin(2,0,4)); // [ 4, 5, 4, 5 ]
    ```

13. 创建数组`Array.of(numb/[el1,el2..])，或Array(numb/[el1,el2,...])`：根据元素构造数组，两个方法仅参数为整数时有区别。

    ```javascript
    Array.of(7);       // [7]
    Array.of(1, 2, '3', [1,2]); // [1, 2, '3', [1,2]]
    
    Array(7);          // [ , , , , , , ]
    Array(1, 2, 3);    // [1, 2, 3]
    ```

14. 数组拼接 `old.concat(e1,[e2...])`：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。


#### 1.1.1.2. 字符串

1. 正则 `match & matchAll`：不改变原字符串。

   1. `match`：返回一个字符串匹配正则表达式的结果。

   2. `matchAll`：返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。(`.next()`取值)

      ```javascript
      const paragraph = 'The quick A brown.';
      const regex = /[A-Z]/g;
      console.log(paragraph.match(regex));// ['T','A']
      
      const regexp = /t(e)(st(\d?))/g;
      const str = 'test1test2';
      // 迭代器 转 数组
      const array = [...str.matchAll(regexp)];
      console.log(array[0]); //["test1", "e", "st1", "1"]
      console.log(array[1]); //["test2", "e", "st2", "2"]
      ```

   3. `/g,/i,/m`：/g查找所有可能；/i匹配时不区分大小写；/m多行匹配

2. 替换 `replace & replaceAll(oldS/pattern,newS)`：是否全部替换，不改变原字符串。

   ```javascript
   let a = 'a b b c';
   console.log(a.replace('b','-')); // a - b c
   console.log(a.replace(/b/i,'-')); // a - b c
   console.log(a.replace(/b/g,'-')); // a - - c
   console.log(a.replaceAll('b','-')); // a - - c
   ```

3. 截取 `substr & substring`：

   1. `substr(start,len)`：已经不建议使用了，从index开始截取len个字符，负值表示从右往左截取。
   2. `substring（start,end）`：开始到结束截取一段，小于0的认为是0，大于长度的认为是长度。(即使start>end，输出仍按从左到右)。

4. 分割 `str.split(sep,limit)`：sep为‘’，‘ ’，默认，含义不同。

   ```javascript
   const str = 'The quick brown  fox jumps.';
   
   // ["The", "quick", "brown", "", fox", "jumps""]
   console.log(str.split(' '));
   
   // ["T", "h", "e", " ", "q", "u", "i", "c", "k", " ", ...]
   console.log(str.split(''));
   
   //["The quick brown  fox jumps."]
   console.log(str.split());
   ```

#### 1.1.1.3. 数学&运算符

1. 传参为null，默认按0处理。传参错误默认返回NaN

2. NaN!==NaN

3. abs

4. sqrt/cbrt (平方根/立方根)

5. pow (求次方)

6. hypot (勾股定理，求两个数平方和的平方根 (3, 4) =>5)

   cos/sin/tan （正余弦） ;acos/asin/atan （反正余弦）;cosh/sinh/tanh （双曲正余弦） ;acosh/asinh/atanh （反双曲正余弦） 

7. max/min (最大值/最小值)

8. random （随机数 [0, 1) )

9. floor/ceil/round/trunc(向下取整/向上取整/四舍五入/去掉小数部分，不进行数值计算)，取整注意负数。 

   ```javascript
   // 上取整ceil
   console.log(Math.ceil(7.004)); // 8
   console.log(Math.ceil(-7.004)); // -7
   // trunc去掉小数(忽略 正负数)
   console.log(Math.trunc(7.005)); // 7
   console.log(Math.trunc(-7.005)); // -7
   ```

10. 运算符 +：

    ```javascript
    console.log(2+2); // 4
    console.log(2+true); // 3，布尔+数=数
    console.log( true +'123') // "true123"，布尔+串=串
    console.log('hi'+'wir'); // hiwir
    console.log(20+'say'); // 20say， 数+串=串
    
    console.log(null + 1 === 1); // true
    console.log( '0'== false) // true
    ```

11. 幂运算**：比较特殊，幂运算为右结合。

    ```javascript
    console.log(2**3**3) // 相当于2**(3**2)=512
    ```

12. 逻辑运算

    1. `A && B`逻辑与：符号前面为true则继续向后匹配，匹配到false或者匹配到最右端返回当前值。
    2. || 逻辑或：符号前面为false则继续向后匹配，匹配到true或者匹配到最右端返回当前值。
    3. ! 逻辑非：返回相反值。（0、空字符串、undefined、null、false;)（[],{}为true）
    4. ?? 控制合并运算符：当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。

    ```javascript
    console.log( 1&&2&&3 ); // 3， 遇到右端终止
    console.log( 1&&0&&3 ); // 0， 遇到false终止
    console.log( -1||0 ); // -1
    console.log( 0||3 ); // 3
    console.log( (1&&2)||0 ); // 2，=(2)||0=2
    console.log( (1&&0)||2 ); // 2,=(0)||2=2
    
    !0, !'', !undefined, !null // true
    ![], !{} // false
    
    -1 ?? 0 // -1
    undefined ?? 0 // 0
    ```

13. 位运算：&，|，^，~ ：与 或 非 异或。（32位）

    ```javascript
    let a = 5;
    let b = 3;
    a&b // 101 & 011 = 001 = 1
    a|b // 101 | 011 = 111 = 7
    a^b // 101 ^ 011 = 110 = 6
    ~a // ~101 = 010 = 28个1+1010 = -6
    ```

14. 移位运算符：>>、<<（32位）

    ```javascript
    let a = 5 // 000...101 , 32位数
    let b = 3
    a >> b = 00000000000000000000000000000000 = 0
    a << b = 00000000000000000000000000101000 = 40 (5*2*2*2)
    ```

#### 1.1.1.4. 作用域

1. 作用域类别：块作用域、函数作用域、全局作用域

   ```javascript
   // 全局
   var a = 0;
   // 块级..
   {
       let a = 1
   }
   // 函数..
   function test(){
       let b = 2;
   }
   ```

2. 作用域链与作用域嵌套：作用域嵌套后，会形成一个链，即作用域链，当在当前作用域找不到某个变量时，会不断向上追溯，一直到全局作用域。

   ```javascript
   let {log}=console;
   var b = 1;
   
   function case2(){
       function test2(){
           log(b) //  1。方法中未定义，则向上查找》全局作用域
       }
       test2();
   }
   case2();
   ```


#### 1.1.1.5. 变量声明

1. 未声明变量总是全局的;

2. 未声明变量可以被删除，声明的不可以;

   ```javascript
   // 未声明，表示全局; 可删除
   a = 1; 
   delete a; 
   console.log(a); // ReferenceError: a is not defined.
   
   // 已声明；不可删除
   var b = 1;
   delete b;
   console.log(b); // 1
   ```

3. 变量类型Symbol

   ```javascript
   
   let symbom = Symbol()
   let obj ={}
   obj[symbol]='a' // Error: symbol1 is not defined
   
   let symbom1 = Symbol()
   let obj ={
   	[symbol1]:'b' 
   } // Error: symbol1 is not defined
   
   let symbol3 = Symbol('a');
   let symbol4 = Symbol('a');
   console.log(symbol3 == symbol4);// false
   ```

4. 变量声明：var、let、const

   1. var：变量声明，可以跨块作用域，但是不能跨函数作用域。

   2. let：局部变量声明，可作用于块级作用域，在顶端声明时不会变成window的属性，暂存死区，无变量提升

   3. const：常量声明，无法重新赋值改变也不能被重新声明，作用范围与行为同let一致

      ```javascript
      var v = 'hi world';
      (function(){
          console.log(`hi ${v}`);
          var v = 'I love u.' // 若换成let，则报错
      })() // hi undefined 
      ```

5. 变量提升：var有，let/const无; 只提升“声明”，不提升“初始化”的值

   ```javascript
   // 变量声明：只提升“声明”，不提升“初始化”的值
   console.log(c); // undefined
   var c = 3;
   // let/const无变量提升
   console.log(d); // Error: Cannot access 'd' before initialization
   let d = 4;
   ```

#### 1.1.1.6. 类型判断

1. ===：数值+类型是否相等。（1！==’1‘）

#### 1.1.1.7. this指向

1. 对象中的内部方法：其内this指向对象

   ```javascript
   var x=1
   let obj={
   	x:3,
       fn:function(){
         //var x = 2;
         console.log(this.x,this)
       }
   }
   obj.fn.call(obj) // 3
   ```

#### 1.1.1.8. 异步

[promise必会10题](https://zhuanlan.zhihu.com/p/30797777)

1. Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。

   ```javascript
   const promise = new Promise((resolve, reject) => {
     // 构造函数
     console.log(1)
     resolve()
     console.log(2)
   })
   promise.then(() => {
     console.log(3)
   })
   console.log(4)
   // 1 2 4 3
   ```

2. 构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。

   ```javascript
   const promise = new Promise((resolve, reject) => {
     resolve('success1') // 执行
     reject('error')     // 不执行
     resolve('success2') // 不执行
   })
   
   promise.then((res) => {
       console.log('then: ', res)
   }).catch((err) => {
       console.log('catch: ', err)
   })
   // then: success1 
   ```

3. promise 可以链式调用。每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。(catch为执行时错误，或者返回reject时的回调)

   ```javascript
   Promise.resolve(1).then((res) => {
       console.log(res)
       return 2  		  // 通过return返回，不会发生值穿透
     }).catch((err) => { // 不执行
       return 3
     }).then((res) => {  // 参数透传：2
       console.log(res) 
     })
   // 1 2
   ```

4. .then，.catch希望传入的是函数，传入非函数，会发生值穿透

   ```javascript
   Promise.resolve(1).then(2).then(3).then(console.log);
   ```

5. promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。

   ```javascript
   const promise = new Promise((resolve, reject) => {
     setTimeout(() => {
       console.log('once')
       resolve('success')
     }, 1000)
   })
   
   const start = Date.now()
   promise.then((res) => {
     console.log(res, Date.now() - start)
   })
   promise.then((res) => {
     console.log(res, Date.now() - start)
   })
   // output
   once
   success 1005
   success 1007
   ```

6. `.then` 或者 `.catch`中 `return` 一个 `error` 对象并不会抛出错误，所以不会被后续的 `.catch` 捕获，需要改成其中一种。

   ```javascript
   Promise.resolve().then(() => {
       // 以下这种方式，不会被后续catch，相当于return Promise.resolve(new Error('error!!!'))
       return new Error('error!!!')
       // 以下两种方式，会被后续catch
       return Promise.reject(new Error('error!!!'))
       throw new Error('error!!!')
     }).then((res) => {
       console.log('then: ', res)
     }).catch((err) => {
       console.log('catch: ', err)
     })
   // output
   then: Error: error!!!
       at Promise.resolve.then (...)
       at ...
   ```

7. `.then` 或 `.catch` 返回的值不能是 `promise` 本身，否则会造成死循环。类似于

   ```javascript
   const promise = Promise.resolve().then(() => {
       return promise 
   })
   promise.catch(console.error)
   ```

8. `process.nextTick` 和`promise.then` 都属于 ’微任务‘，而 setImmediate 属于 宏任务，在事件循环的 check 阶段执行。事件循环的每个阶段（’宏任务‘）之间都会执行 ’微任务‘，事件循环的开始会先执行一次 ’微任务‘。

   ```javascript
   process.nextTick(() => {
     console.log('nextTick')
   })
   Promise.resolve()
     .then(() => {
       console.log('then')
     })
   setImmediate(() => {
     console.log('setImmediate')
   })
   console.log('end')
   // output
   end
   nextTick
   then
   setImmediate
   ```

#### 1.1.1.9. 对象

1. 设置属性不能修改：

   ```javascript
   var employee = {};
   Object.defineProperty(employee, 'id', {
     writable: false, // 设置属性不能修改：
     value: '9527',
   });
   
   employee.id = '9528'; // 无效
   console.log(employee.id); // 9527
   
   Object.defineProperty(employee, 'id', { //TypeError:不能重定义
     writable: true,
   });
   employee.id = '9529';
   console.log(employee.id);
   ```

#### 1.1.1.10. 类

1. 类的定义：class

   1. 使用类关键字

   2. 可以将类分配给变量

   3. 可以将类导出为ES6模块的一部分

      ```javascript
      class Person {
        constructor() {
          this.name = 'XiaoMing';
        }
      }
      // 将类分配给变量
      Person = class AnotherPerson {
        constructor() {
          this.name = 'XiaoHong';
        }
      };
      const member = new Person();
      console.log(member.name); // XiaoHong
      // 导出
      export default class User {}
      export class User {}
      ```

2. 类的继承：extends

3. super：访问和调用一个对象的父对象上的函数

4. 类的初始化：构造函数 `constructor(p1,p2...)`。如果没有定义，则会创建一个默认的空函数。

5. 类属性：

   1. 声明方式：可以附加到类本身（静态字段）/ 类实例上。

   2. 公有属性：可访问性：public在任何地方访问；

   3. 私有属性：private只能再类的主体中访问(`#paramName`)。

      ```javascript
      // 私有属性
      Person = class AnotherPerson {
        #age = 2; // 私有属性；附加到类本身上
        constructor() {
          this.#age = 5; // 改变私有属性的值
          this.name = 'Hong'; // 公共属性；附加到类实例上
        }
      };
      const member = new Person();
      // 注意：#age和age不同，#age才是私有属性
      console.log(member.age);//Hong,Undefined
      console.log(member.#age); //Error: Private field '#age' must be declared in an enclosing class
      ```

   4. 静态属性：`static`修饰，不可改变类本身的值，但可改变其实例的静态属性值。

      ```javascript
      // 静态属性
      class User {
        static TYPE_ADMIN = "admin";
        type;
        constructor(type) {
           this.TYPE_ADMIN = 'adminTest' //只能改变实例上的值
           this.type = type;
        }
      }
      const admin = new User(User.TYPE_ADMIN);
      const admin1 = new User('customer');
      console.log(User.TYPE_ADMIN, admin.TYPE_ADMIN); //"admin" "adminTest"
      ```

6. 类的方法：

   1. **静态方法**：修饰符static，直接附加到类的函数。

      1. 权限：可以访问静态属性,不能访问实例/私有属性。
      2. 调用：可在类外被类/类实例调用。

   2. **公有方法**：

      1. 权限：可访问公有属性/方法、但不能访问静态属性，可调用静态方法。
      2. 调用：可在类外被类/类实例调用。

   3. **私有化方法**：

      1. 权限：可以访问类内部的所有属性：即私有属性和公有属性。
      2. 调用：不能在类外调用。

   4. **getter和setter** 

      ```javascript
      class User {
          #nameValue;
          constructor(name) {
              this.name = name;
          }
          get name() { // getter方法
              return this.#nameValue;
          }
          set name(name) {// setter方法
              if (name === "") {
                  throw new Error(`name cannot be empty`);
              }
              this.#nameValue = name;
          }
      }
      const user = new User("Fundebug");
      user.name; // getter 被调用, => 'Fundebug'
      user.name = "Code"; // setter 被调用
      user.name = ""; // setter 抛出一个错误
      ```

7. 类的原型方法：

   ```javascript
   class Test {
       x = 1
       constructor() {
         this.x = 2; // 修改实例绑定的变量
         this.run = function () {
           console.log(this.x);
         }
       }
      run() { console.log(this.x);} // 私有方法
   }
   // 修改类的原型方法
   Test.prototype.run = function () {
     console.log(3);
   }
   let t = new Test();
   // 修改类的原型方法
   Test.prototype.run = function () {
     console.log(4);
   }
   // output
   t.run(); // 2
   Test.prototype.run(); // 4
   ```

#### 1.1.1.11. 继承



#### 1.1.1.12. 函数



#### 1.1.1.13. 闭包

1. 返回嵌套方法

   ```javascript
   var x = 4;
   function outside() {
     let x = 5;
     function inside(x) { // 形参x，跟前面定义的非同一个
       return x * 2;
     }
     return inside; // 返回一个inside方法
   }
   console.log(outside()(10)); // 20
   console.log(outside()()); // NaN
   ```

#### 1.1.1.14. export

1. 同：均可用于导出常量、函数、文件、模块等。（可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入）
2. 异：（1）在一个文件或模块中，export、import可以有多个，export default仅有一个；（2）通过export方式导出，在导入时要加{ }，export default则不需要。

### 1.1.2. 框架
熟练掌握JavaScript主流框架的原理、差异

1. vue：Object.defineProperty( )只能使用setter/getter方法，无法监听属性的新增、删除？（无法监听新增的对象属性的变化，可手动设置`Vue.set()`）。
2. Chrome可以使用Proxy实现双向绑定（对）
3. vue：路由管理，hash模式
   1. 能够在 window 上绑定 hashchange 事件监听器实现前端路由的跳转处理
   2. hash 指的是 URL 末尾以 # 开始的一段字符串
   3. 浏览器路径里的 hash 部分对后端是无感知的
   4. **修改 location.hash 会触发浏览器请求到后端**（错）

### 1.1.3. http
了解HTTP服务基础概念，如路由、代理、缓存

1. cookie和webstorage/indexDB区别（见JS笔记）[MDN解释](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage)
   1. cookie：用于CB之间交互
   2. webstorage：用于存储和检索较小的、键值对型数据。比如用户的名字，用户是否登录。
   3. IndexedDB：为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。
2. 浏览器的渲染过程：dom树》样式表》render树》布局》绘制页面。
3. window对象的属性：
   1. location: 获取/设置其url
   2. frames：只读，返回所有子窗体的数组
   3. history：只读，返回一个对history对象的引用
   4. arguments：无该属性
4. 关于缓存的说法，错误的是：
   1. cookie、localStorage、sessionStorage可以通过getItem,setItem进行读写。（错。cookie的读取方式：`request.getCookies()`；写入：`document.cookie = '...'`）
   2.  cookie的生命周期取决于Max-Age和Expires，sessionStorage随浏览器关闭而结束，localStorage永久存在，除非手工清除。
   3. cookie可以在网络请求中被携带，发送至服务器；sessionStorage和localStorage不可以。
   4. 相对于cookie、localStorage、sessionStorage，IndexedDB是唯一支持异步操作的存储方式，所以在service worker中常用IndexedDB做为存储。

### 1.1.4. HTML&CSS

掌握HTML/CSS的基础特性和语法，如表单元素、超链接等常用标签，浮动、定位等页面布局。
熟悉掌握BOM（浏览器对象模型，提供与浏览器交互的方法和接口）、DOM（文档对象模型，提供访问和操作网页内容的方法和接口）相关编程操作;掌握常用的DOM操作（元素的创建、插入、删除）;掌握CSS选择器的分类、优先级和基础用法;

1. DOM操作

   1. 在满足业务特性需求的情况下，减少DOM对象的动态创建和删除
   2. 页面卸载、动态删除的 DOM 对象时要先注销绑定的事件监听
   3. 不建议在HTML标签上嵌入JavaScript事件回调代码

2. 元素选择器效率：依次降低

   - id选择器（#myid）》 标签选择器（div,h1,p）》类选择器（.myclassname）》相邻选择器（h1+p）》子选择器（ul > li）》后代选择器（li a）》通配符选择器（*）》属性选择器（a[rel="external"]）》  伪类选择器（a:hover,li:nth-child）。
   
   - 内联样式 > ID 选择器 > 类选择器 = 属性选择器（a[rel="external"]） = 伪类选择器 （a:hover,li:nth-child）> 元素（类型）选择器 = 伪元素选择器
   
3. 元素定位：`position`

   1. **static**：默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right或者z-index声明）。
   2. **relative**：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常位置进行定位。可通过z-index进行层次分级。
   3. **absolute**：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过"left","top","right"以及"bottom"属性进行规定。可通过z-index进行层次分级。
   4. **fixed**：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过"left","top","right"以及"bottom"属性进行规定。可通过z-index进行层次分级。
   5. **relative和absolute区别**：absolute不受父元素里的其他元素影响，而relative会受到父元素里的其他元素影响。

4. **在 HTML 中，以下关于 position 属性的设定值描述错误的是（ 2）**

   1. static 为默认值，没有定位，元素按照标准流进行布
   2. relative属性值设置元素的相对定位，垂直方向的偏移量使用 up 或 down 属性来指定（）
   3. absolute 表示绝对定位，需要配合 top、right、bottom、left 属性来实现元素的偏移量
   4. 用来实现偏移量的 left 和 right 等属性的值，可以为负数

## 1.2. 安全规范

### CSRF

1.  CSRF攻击：

   1. 定义：跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
   2. 原理：可伪造当前用户的行为，让目标服务器误以为请求由当前用户发起，并利用当前用户权限实现业务请求伪造。
   3. 防护：（1）添加中间环节，如验证码机制，伪造的请求无法添加验证码。（2）验证用户请求的合法性：验证referer，是否伪造，该值不同。（3）利用token，token需为一次性、随机的，由服务器发给客户端。

2. 关于CSRF攻击，说法正确的是：

   1. 攻击者伪造了用户的身份信息（F，利用身份信息）
   2. 对server来讲，用户信息是有效的
   3. CSRF一般由服务端来解决，客户端不需要关注
   4. 攻击者伪造了用户的http(s)请求（正确）

### 外部数据

1.  **以下哪个不属于安全编码中的外部数据（4 ）**
   1. 浏览器地址栏的输入数据
   2. localstorage中存储的数据（注意）
   3. 通过form表单输入的数据
   4. 代码中定义的函数 

## 1.3. 通用规范

### 命名

1. 类/构造函数：大驼峰。
2. 变量、方法：小驼峰（私有的，开头/结尾加“_”）。
3. 常量：全大写，下划线分隔。
4. 缩写单词：15字符以下不用；超过的可省略元音，且缩写单词要全大写/小写。
5. 禁用：保留字、否定的布尔变量。

### 注释

1. 目的：解释代码意图，而非描述如何做
2. 风格：单行//，块/* */，文档/** */
3. 位置：放在所注释代码上方；注释和上面的代码间要有空行
4. 正式交付给客户的代码不应包含TODO/FIXME 注释
5. 不要用注释记录修改日志

### 排版

1. 缩进：2空格

2. 换行

   1. 原则：高句法级别处、操作符放行首
   2. 方法参数：尽量一行；若超过120，则可以让每个参数单独一行以示强调。
   3. 对象字面量、控制语句中的每个条件（组）：要么单独一行，要么所有属性都在同一行。
   4. 链式调用对象方法时，一行最多调用4次，否则需要换行

3. 空行

   1. 加空行：独立的代码块之间、class成员变量之间
   2. 不加空行：方法体内部的 开始/结束

4. 空格

   1. `if/else/for/catch`： 如`if (start) {, else {`

   2. 一般`{`之前都要加，**有2个例外**：（1）作为函数的第一个参数；（2）作为数组的第一个元素。

   3. 在任何二元或三元运算符的两侧增加空格。

   4. 在操作符 +、-、*、=、<、>、<=、>=、===、!==、&&、|| 前后带个空格。

   5. 数组初始化中的逗号和函数中多个参数之间的逗号**后**带个空格。

      

   6. 在逗号 ，或分号；之前**不允许**使用空格。

   7. 数组的括号内不要有空格

5. 花括号：给if、for、do、while等语句的执行体加花括号 {}；且左括号和语句在同一行。

### 最佳实践

1. 子目录和文件数：不超过50
2. 文件长度：不超过2k行
3. 每行代码：120字符
4. 方法长度：50
5. 圈复杂度：20
6. 块语句、回调函数的最大嵌套深度：4

### 变量

1. 使用const、let代替var
2. 在需要时候声明变量，并且尽快初始化，不用提到方法的初始位置
3. 每行声明一个变量，禁止连续赋值
4. 无需用undefined声明（不赋值，默认就是）
5. 禁止内外层变量同名，防止覆盖

### 方法

1. 参数：<=5
2. 可以给参数指定默认值，而不是在方法内处理为空的情况
3. 不要修改传参，可重新定义变量
4. 默认参数放在末尾
5. 参数使用前需要做合法性判断
6. 优先使用参数解构（只能是简写属性，不能是嵌套/计算属性）
7. 保证 函数声明/函数表达式的一致性，统一使用一种。（函数声明会被提升到作用域顶部，函数表达式不会）
8. 匿名函数，优先使用箭头函数，不要保存 this 的引用。
9. 箭头函数一行时，要简写：可省花括号和return。
10. 明确指出return 内容，单纯return，会返回undefined。
11. 函数返回多个值时，使用对象结构，而不是数组结构。

### 类&对象

1. 类

   1. 在构造函数中禁止在调用super()之前使用this或super。
   2. 在构造函数中一次性设置所有对象的属性
   3. 只用基类调用静态方法
   4. 方法可以返回this以支持方法的链式调用

2. 字符串

   1. 单引号替换双引号
   2. 含模板字符串：用反引号
   3. 不使用`/`作为换行拼接符，而是拆分为两个字符串

3. 数组

   1. 数组赋值：用`arr.push(el)`。
   2. 数组复制：`...`
   3. 数组中添加元素：不要给数组添加属性，而是用map，object替代。
   4. 数组取值：数组解构
   5. 数组遍历：应该优先使用`Array`对象方法：`forEach、map、every、filter、find、findIndex、reduce、some`
   6. 不要给数组添加属性，而是用map，object替代。

4. 对象

   1. 属性名称建议使用标识符，而非字符串（只有属性名称中含有特殊字符时，才使用字符串，如`'data-blash'`)
   2. 推荐使用属性简写、方法简写
   3. 访问属性：一般用`.`，属性名为动态时，才用`[]`。
   4. getter和setter应该成对出现在对象中。
   5. 禁止在对象实例上直接使用 Object.prototypes 的内置属性。
   6. 遍历对象的属性：推荐使用`Object.keys().forEach()`；不要用for-in，否则会包含原型上的属性。
   7. 不要修改内置对象的原型/向原型添加方法。
   8. 对象复制：`...`

### 运算与表达式

1. 条件表达式

   1. 变量在前，字面量在后，如`color=='red'`。
   2. if简写：undefined、null、布尔false、数字0，NaN, 空串，都为false，无需再与false比较。（注：对象为true）。
   3. 复杂的表达式，建议提取为方法。
   4. 不要在“复杂的表达式”前加 否定“!”
   5. 不要使用否定表达式
   6. 禁止使用嵌套的三元表达式

2. 控制语句

   1. switch若无需default，应加空的`default`或加注释`//no default`
   2. switch中case内的变量声明，含有`let、const`时要用`{}`包裹。
   3. `if-else if-else`：最后一定要有`else`
   4. 不要用逻辑运算符代替控制语句

3. 正则

   1. 禁止在正则表达式字面量中出现多个空格

   2. 建议在正则表达式中使用**命名捕获组**(语法`?<name>..`，作用类似于给表达式命名)

### 其他语言特性

1. 作用域
   1. this是函数运行时所在的环境对象，是变化的。
      1. 表示定义时所在的环境对象（如：箭头函数，注意箭头函数的this不会改变）
      2.  表示全局对象window（如：在最外层作用域调用函数，或者单独使用时）
      3. 表示调用者的所在的环境对象（如：使用eval时）
      4. 表示接收事件的DOM元素（如：事件处理函数时）
      5. 表示该方法所属的对象（如：在类的构造器、方法中）
      6. 类似 call() 和 apply() 方法可以将 this 引用到任何对象
   2. this只适用于以下场景
      1. 函数是一个构造函数
      2. 函数是一个方法
      3. 允许在以下函数中出现this 关键字：（1）调用了改函数的call/apply/bind 方法。（2）如果给出 thisArg，该函数是数组方法的一个回调（比如.forEach()）。（3）函数在 JSDoc 注释标记中有@this 标签。
   3. 不要在顶级作用域下使用变量和函数声明，要么显式赋值给window，要么包裹再IIFE中（立即调用表达式）。
   4. 尽量少在window上添加属性、方法，若必须，请使用唯一的命名空间。
   5. 
2. 模块
   1. 模块导入，推荐ES6的`import/export`方式。
   2. 不要使用通配符`import *`
   3. 导入的顺序依次为内置模块（如：Nodejs模块）、外部模块、内部模块
   4. 导入时，建议不加JS文件扩展名
   5. 不使用绝对路径
   6. import的三方件需要加入到`package.json`依赖中
   7. 文件名、类名、以及默认导出的名称应该尽量保持一致
   8. 导出的变量必须是const类型或不可变的类型
   9. 不要从 import 中直接 export
3. 数值与计算
   1. 禁止省略小数点前后的0
   2. 要求调用 isNaN() 检查 NaN（NaN不等于任何值）
4. 异常
   1. 抛出异常，应用`Error`类封装。
   2. 若捕获了异常，但不处理，应注释说明原因。
   3. `promise`中，`reject`应返回`Error`对象。
   4. 禁止在`finally`中使用控制流语句（`return/throw/break/continue`），否则会覆盖`try、catch`中的语句结果。
5. 异步
   1. 禁止在`async funciton `中进行不必要的`return await`。
6. 避免
   1. 禁止使用`eval(val)`,只有val为字符串，才执行，否则直接返回。推荐使用`JSON.parse(mstr)`来解析字符串。
   2. 使用`setTimeout()、setInterval() 或者 execScript() (仅限IE浏览器)`时，注意使用方式。
   3. 禁止使用`with()`，会使语义不清晰。
   4. 建议不使用`continue()`，会降低可测、可读、可维护性。
   5. 发布前，删除调试信息：`debugger/console/alert/confirm/prompt`
   6. 禁止多余的`return`，如`if/default`结尾。
   7. 不要在html中嵌入大量的JS、css代码。
7. ES5
   1. ES5无块作用域的概念，故块内变量不能与函数内的其他变量同名。
   2. 不要在一个非函数代码块（if/while等)中进行函数声明，严格模式下会报错。
   3. var声明会被提升至该作用域的顶部，所以变量声明应该在作用域顶部。
   4. ECMAscript 5，建议函数内部使用 “use strict”。

### 性能

1. JQ
   1. 规则68 缓存jQuery查询结果
   2. 规则69 避免所有元素选择器(*)
   3. 规则70 优先使用ID选中器(#)，尽量给选择器指定上下文context
   4. 循环中减少DOM操作
   5. 规则72 利用事件代理(冒泡)机制
2. 其他
   1. 尽量不要使用同步的请求，避免页面卡顿。
   2. 建议70 尽量减少界面DOM的更新
   3. 规则74 减少HTML标签数量

## 1.4. 调试与定位

【大纲】
- 《chrome开发者工具》
- 掌握主流浏览器（chrome70+、 IE11）的兼容性
- 掌握WEB常见性能问题定位方法（console调试/ Chrome开发者工具的Performance分析）。
- 掌握常见HTTP异常状态码，Server端错误异常处理、HTTP消息头
- 了解浏览器渲染引擎工作机制

## 1.5. 测试开发与执行

- 测试设计（含理念、方法、用例设计）
- 测试基础理论与设计方法，包括单元测试、集成测试、系统测试
- 掌握组合测试设计方法、可靠性测试方法、性能测试方法、可测试性分析与设计方法
- 掌握用例质量评估方法、测试框架质量分析
- 测试实现与执行
- 掌握白盒测试的框架搭建及应用
- MOCK概念与使用方法（JavaScript)
- 测试用例与环境解耦的方法(可独立执行，不依赖于外部条件)
- 覆盖率的分类(函数、代码行、分支覆盖率)
- 掌握测试框架扩展原则（易用性、稳定性、高效性）
- 掌握重构测试准备的基本原理与设计方法
- 测试代码重构常用技能方法

1. 组合因子

   AC: a*b*c

   BC: 所有因子个数和-因子个数+1

   EC: 最大因子个数

   Pair-wise：最大因子个数*次大因子个数

   

## 1.6. 编译与构建

【大纲】
- 熟练掌握Webpack的用法与原理
- 掌握Node.js中fs、path等常用工具库用法 
- 掌握UMD/CommonJS/ES modules基本概念
- 了解包管理机制/仓库镜像/版本规范等基础知识

## 1.7. 真题

1. 数组方法：哪个方法不能改变自身数组？splice/concat/sort/pop (concat)

2. 字符串：模板字面量+字符串不可修改(修改不报错)

   ```javascript
   let a = 'word'
   console.log('hello' ${a}); // hello word
   a[0] = 's'
   console.log('hello' ${a}); // hello word
   ```

3. 正则匹配： `match & matchAll`

4. 字符串分割 split、子串substring/substr、替换replace/replaceAll

5. 对象的key，仍可以是对象

6. ‘0’==false // true

7. class的实例化，必须加new

8. 方法.length，为参数个数

9. 箭头函数没有原型

