[TOC]

## 总结

1. 操作：（按位进行）与&，或|，异或^，取反~。
2. 异或的性质：
   - 相同为 0，不同为 1.
   - 任何数与 0 做异或，为他本身
   - 满足交换律。

## 分类练习

- 只出现一次的数字 136 E
- 137.只出现一次的数字 2
- 面试题 56 - I. 数组中数字出现的次数 （同 260）
- 365 水壶问题 （中）
- 1513.仅含 1 的子串数 M
- 12.整数转罗马数字 M

### 只出现一次的数字 136 E

1. 题目要求
   - 只有 1 个数字出现了 1 次，剩下都是 2 次
   - 不使用额外空间，复杂度尽量低
2. 思路：
   1. 哈希表：空间复杂度不符合要求
   2. 排序：时间复杂度高
   3. 异或：满足题意，相同为 0，相异为 1。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 异或
        res = 0
        for el in nums:
            res ^= el
        return res
```

### 137.只出现一次的数字 2

1. 题目要求
   - 只有 1 个数字出现了 1 次，剩下都是 3 次
   - 时空复杂度，都是 O(n)
2. 思路
   1. set：`3*sum(set(arr))-sum(arr)`,均 O(n)。
   2. Counter：计算所有数出现次数，均 O(n)。
   3. 位运算：

### 面试题 56 - I. 数组中数字出现的次数 （同 260）

1. 技巧
   1. 任何数和本身异或则为 0；
   2. 两个独特的的数字分成不同组；
   3. 其余的数，保证每对相同的数分到同一组；
   4. 通过将数字&1，判断结果的最后一位是否为 1，可将数字进行奇偶分组；
2. 代码

```python
def singleNumbers(nums):
    ret = 0  # 所有数字异或的结果
    a = 0
    b = 0
    # ret最终结果，为两数的异或结果
    for n in nums:
        ret ^= n
    # 通过与1进行异或操作，找到二进制的最后一位不是0的数
    # 由此可将数分为两组
    h = 1
    while (ret & h == 0):
        h <<= 1
    for n in nums:
        # 根据该位是否为0将其分为两组
        if (h & n == 0):
            a ^= n
        else:
            b ^= n
    return [a, b]
```

### 365 水壶问题 （中）：数学 贝祖定理

1. 题目分析：
   1. 题中允许的操作：
      1. 将 2 个壶灌满/清空；
      2. 将 1 个壶中水注入另 1 个壶中，直到灌满/倒空； 2. x,y 两壶的状态：空/满，不存在半壶的情况；
      3. 最终用 1 或 2 个壶装所有的水，因此 2 壶总量必须大于 z；
2. 解题思路 1：贝祖定理 时间 O(log(max(a,b)))
   1. 对任何整数 a、b 和它们的最大公约数 d，关于未知数 x 和 y 的线性丢番图方程（称为裴蜀等式）：ax + by = m，有解当且仅当 m 是 d 的倍数。裴蜀等式有解时必然有无穷多个整数解。
   2. 方程 ax + by = 1 有解当且仅当整数 a 和 b 互素；（即最大公约数为 1）
   3. 因此，判断 z 是否为 x,y 的最大公约数 的倍数，是则返回 true。
3. 解题思路 2： dfs/bfs 1. 操作集：

```python
def canMeasureWater1(x, y, z):
    # 若 z 为 0，则一定为 true；
    return x + y >= z and (z == 0 or z == y or z == x or z % math.gcd(x, y) == 0)
```

### 1513.仅含 1 的子串数 M

- 题目：问'01101110'中，有多少含有 1 的子串
- 技术：数学
- 关键：
  1. 计算长度为 k 的串，可以形成多少子串？公式：k(k+1)//2; 如'111':1,1,1,11,11,111，共 6 个；
  2. 结果取模：x%=(10**9+7), 10^9 即 10**9

### 12.整数转罗马数字 M

- 算法：贪心,divmod(7,2)=7//2,7%2;
- 技巧：每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。
- 举例：171=100+50+10+10+1

```python
class Solution12:
    def intToRoman(self, num: int) -> str:
        digits = [(1000, "M"), (900, "CM"), (500, "D"), (400, "CD"), (100, "C"), (90, "XC"),
          (50, "L"), (40, "XL"), (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")]
        res = []
        for numb,symbol in digits:
            # 终止条件
            if num==0:break
            # 若果num比numb小，则count=0，不会计入结果集；
            count,num = divmod(num,numb)
            res.append(symbol*count)
        return ''.join(res)
    def intToRoman1(self, num: int) -> str:
        digits = [(1000, "M"), (900, "CM"), (500, "D"), (400, "CD"), (100, "C"), (90, "XC"),
          (50, "L"), (40, "XL"), (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")]
        index = 0
        res = ''
        while index<len(digits):
            while num>=digits[index][0]:
                res+=digits[index][1]
                num -=digits[index][0]
        return res
```
