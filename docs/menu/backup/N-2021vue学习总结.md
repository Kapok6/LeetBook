

## 1. 待办

1. 部署配置 nginx
2. 选择器开发
    1. 开发：下拉列表`option`组件
    2. 开发：整体功能
        1. 远程搜索(1)
        2. 过滤，涉及到自动勾选(1)
        3. v-model 待完善
        4. 布局完善
    3. 完善：输入框+tag 组件
        1. 添加 tooltip
        2. 图标替换
        3. 测试：tag 折叠显示
    4. 完善：弹框
        1. 选中、删除逻辑：`list`
        2. 确定、取消逻辑：list/tree
        3. 输入数据兼容处理
3. 待改进点：
    1. tagkey,datakey : label,value
    2. valuekey：空、单值、path
    3. 预研：renderError 怎么用
    4. common.data
4. GUI 渲染：
    1. event loop，红任务、微任务
    2. 宏任务执行完，会清空微任务；
    3. 宏任务及微任务都有哪些
    4. 队列都有很多种类
5. 有空去写一下 windows 程序，入个门就行。这些都自己的技术视野都有莫大的好处

## 2. 基础选择器

### 2.1. 基础选择器诉求

1. 是否多选：multiple：true/false
2. 是否可清空：clearable: true/false
3. 操作类型：opType: select/filter/remote (methods)
4. 是否支持过滤：filterable, filterMethod
5. 是否支持远程：remote, remoteMethods
6. 数据展示形式：dataDisplay：list/ tree/ table
7. 结果展示：resDisplay: all/folder
8. 数据渲染类型：showType: popover/dialog
9. 输入数据兼容处理

  ![image-20210804115120298](N-开发记录.assets/image-20210804115120298.png)

### 2.2. 常见场景

1. 选择、单/多、列表、popover
2. 本地过滤、单/多、列表、popover
3. 本地过滤、多/单选、树结构、popover
4. 远程搜索、多/单选、列表、popover
5. 本地过滤、单选、树、对话框
6. 选择、多选、树、对话框

### 2.3. 组件设计

1. tag 几种情况，可以抽取为一个组件

2. 数据展示形式 tree、list、table，抽取为一个组件

3. 是否多选：只控制 tag 的展示，只保留一个 input 框

4. 开发顺序：先搭架构，定义输入、输出

5. 选人组件：多了几个钩子函数 beforeinput/afterinput/能否选中 select/
   
    ![image-20210809115304519](N-开发记录.assets/image-20210809115304519.png)
    

### 2.4. 代码修改建议

1. 参数：分类》提取为对象
2. 命名：data>dataSource，delete>remove，resShowType>
3. data 形式

### 2.5. 功能实现逻辑

1. `DisplayInput`：
   1. tag展示
      1. v-model传入“已选值”
      2. 通过计算属性selected，存储传入的值
      3. 定义变量comSelected，存储selected对应的全量数据，供tag展示
      4. watch监听selected，改变时，更新comSelected值
   2. tag删除
      1. 删除tag：直接修改comSelected
      2. watch监听comSelected，改变时，通知父级，改变v-model值，进而改变selected
2. Table：
   1. tag更新后，table自动选中
      1. props传入已选中值：this.common.selected
      2. 添加计算属性 allSelected，用于watch监听，当改变时，刷新表格选中状态
      3. 定义变量 curSelected，用于修改，在created中进行赋值
      4. 定义表格自动选中方法：通过toggleRowSelection，设置表格的某一行为选中。
      5. 何时调用“自动选中”方法：watch-allSelected，以及弹框打开时。
   2. table手动选中，tag联动
      1. 选中/取消：更改curSelected
      2. watch-curSelected，通知父类更新“已选项”

### 2.6. 开发记录、问题、解决

   1. 增加过滤后，popover不出现
      dialog中的弹框，也绑定了popover，去掉绑定即可。
      
   2. 设置v-model后，表格/树的勾选状态无法同步
      1. 选中的数据以及表格展示的数据,必须是同一个对象的数据，而且不能深拷贝。
      2. 设置选中:` this.$refs.tableRef.toggleRowSelection(row, true);`。
      3. 设置选中，需要在dom挂在之后执行，尤其是弹框中的选中。(`nextTick`)。
      
   3. popover-单/多选-表格：搜索已选择的值，data未勾选；清空后，表格选中态未清空；触发搜索后，若不选择，data无法复原到全量数据。
      
      1. `input focus`时，重置data和选中状态。
      
   4. popover-多选-表格：精确匹配后，取消选择，会全部清空之前的选择，只保留当前勾选/取消。
   
      1. rowselect时，精确匹配后， `this.$refs.tableRef.selection`的筛选结果为匹配的值，所以会清空之前的勾选，只保留当前次操作。
   
   5. popover-单选-表格：清空后，选中状态无法清空
   
      1. 单选情况，通过设置`setCurrentRow`高亮了当前行，可在clear中进行取消设置。
      
   6. dialog-多选-表格：触发搜索后，再勾选无效果。
   
      1. `tableRender`中，`watch：data`重置了表格数据，去掉。
   
   7. 树的递归搜索有问题
   
      1. 使用原始方法
   
   8. 弹框-表格-搜索：blur和data的click事件会冲突。
   
      1. blur延迟100ms
   
   9. 表格-搜索：输入已选择的值时，data无法筛选成功/更新。

   10. 弹框-表格-单选-搜索：弹框打开时，input为空。

   11. 弹框-表格-搜索：弹框关闭时，input未清空。

   12. V20210907：+表格搜索，+pop多次点击收缩，-弹框blur有问题

       - [ ] 表格-弹框-单/多选：选中后》“取消”》关闭弹窗》打开弹窗：选择未重置

       - [ ] 表格-弹框-多选：rowclick会显示选中：应该禁止设置setcur

       - [ ] 表格-弹框-单选：有选择，blur后：data会显示筛选后结果

       - [x] 表格-弹框-单选：初始化报错，can't read propertity filter of undefined

         A：刚开始弹框未加载，无需进行过滤

   13. V20210908：+树搜索

          1. 树-pop-单选：
       
             - [x] pop展开：data非全量
       
               A：添加`resetData`
       
             - [x] 聚焦清空后，已展开项不会收起 (9.8 20:31)
       
               A：修改clearVal方法，添加清空操作 
       
             - [x] 失焦清空，无效（**几个场景都有问题**）(9.8 20:31)
             
                A：修改clearVal方法，添加清空操作（但是会有问题，清空input》触发multiSelected》触发query改变》触发reset》触发inputClick》pop/dia展示）
             
             - [ ] 弹框双击可关闭，弹框关闭时仍可输入内容，且不会触发pop。（**pop-单选，都存在该问题**）
       
          2. 树-pop-多选：
             - [x] pop展开：data未勾选
       
               A：添加`resetData`
             
             - [x] 搜索》选择：已选内容被替换
             
               A：过滤时，获取的选择结果为当前次的，需要额外拼接之前的（`treeSelect`）
             
             - [x] 搜索》选择：选择有时失灵
             
               A：`treeSelect`获取已选择值有问题，方法同上。
             
          3. 树-弹框-单选：
             
             - [x] 弹框首次展示：input未回填
             
               A：更新input的值太晚，导致没刷新》使用`nextTick`
             
             - [x] 内部清空》保存：data未重置，弹框关闭后input未回填
             
               A：delOne方法有误，没有更新allselected；另外input更新会触发qchange进而触发`resetData`会重置为上次已选项。（修改：在`clear`方法中，重置表格数据及状态）（9.8 8pm)
             
          4. 树-弹框-多选：
             
             - [x] 内部清空》保存：已展开项不会收起
             
               A：同单选清空的问题，在`clear`方法中，重置表格数据及状态）（9.8 8pm)
             
          5. 表格-pop-单选
       
             - [x] 清空后，已选择项不会取消高亮(9.8 20:31)
       
               A：修改tempClear方法。
       
          6. 表格-pop-多选
       
          7. 表格-弹框-单选
       
             - [x] 清空后，已选择项不会取消高亮，且关闭后input未回填（树也有问题）
       
               A：修改tempClear方法。
       
             - [ ] 选择/blur后，会进行过滤
       
          8. 表格-弹框-多选
       
   14. V20210909 上午：bug修复

          1. 非过滤-树-pop-多选 **（T）**
                   1. 问题1：（非）过滤-树-pop-多选：失焦时，删除某个，会导致全部清空。
                   2. 问题2：（非）过滤-树-pop-多选：聚焦时，删除某个，会导致data的选中效果重置。
                3. 原因：`treeRender`中，`data`变化时会重新渲染`allData`，导致数据重置，所有选择被清空，进而导致`delSelect()`中获取“已选项”错误。
             2. 非过滤-树/表格-弹框-单选 **（T）**
             1. 问题1：非过滤-树/表格-弹框-单选：选中后，结果会显示过滤后的效果。
             2. 问题2：非过滤-表格（树）-弹框-单选：清空后，仍会有选中（展开）效果。
             3. 问题3：过滤-树/表-pop-单选：focus，input未清空。
             4. 原因：select(inputFocus())有问题，没有区分“是否过滤”的场景。
             3. input框readonly逻辑有问题 **（T）**
       
   15. V20210909 下午：bug修复，+选人组件
       
          1. pop-多选：不点开pop》直接删除tag，会清空。**（T）**
                      1. 原因：首次删除时，调用dataRender中的delSelect()》调用rmSelByKey()，此时allSelected未初始化，为空，导致删除失败。
          2. dia-单选：内层input清空，保存后无效。**（T）**
                1. 清空后，又触发了reset操作，会用已选项重置。》当placeholder、query同时为空时，且**为单选时**（多选需要重置），证明使用了clear，不再触发query及reset操作。
          3. 优化代码：调用lodash，删除废弃，抽取方法。
             4. 待完善：backfill，深层过滤有问题
             5. 失焦清空，会导致pop/dia出现
             6. +blur事件，选中后全量展示
       
   16. V20210910 ：

       1. 调整搜索图标：设置不同类型默认值，配置父》孙插槽 。 **（T）** 上午
       2. +远程搜索：场景梳理、
       3. +选人组件

   17. V20210911：

          1. 架构调整：改为数据驱动的模式
       
                   1. 搜索部分、dataRender两部分，使用同一变量代表“已选中”，用v-model。
       
          2. 使用vue过滤器，将过滤后的数据，传给dataRender
       
                   1. 过滤器弊端：无法获取this，因此需要通过参数传递，控制开/关、及调用用户传入的，还是内置的过滤方法。
                   2. 结论：用计算属性进行过滤
       
          3. 交互调整：单选/多选，全部改为2个输入框。
       
             ![image-20210911163303878](N-开发记录.assets/image-20210911163303878.png)
       
   18. V20210913：

           1. +displayinput，filterinput页面&参数配置
           2. +tag多选

   19. V20210914：

          1. 已选项传参设计：对象？字符串？（使用字符串）

          2. **watch已选项：数组未改变，仍会一直触发监听。**（通过lodash判断值是否等）

          3. **watch已选项，数组改变，但新旧值相同**，无法监听到旧值。原因如下。（可使用计算属性作为中间量，然后监听计算属性，具体查看DisplayInput中tag的展示和删除）

             ![image-20210914112145514](N-开发记录.assets/image-20210914112145514.png)
             
          4. table自动&手动选中：

                1. 关键1：已选数据，需要直接使用表格行数据，不能自己重新构造。
                2. 关键2：设置勾选态，需要判断弹框是否展示，进而进行勾选。

          5. table过滤：过滤后，需展示已勾选数据（在table中监听数据变化，触发表格更新）

   20. V20210915：

             1. 表格-单选-选中/取消（ ` this.$refs.tableRef.setCurrentRow(el)`）

   21. 

## 3. 组件开发&调试入口

1. 方法 1：直接开发新入口

    1. `package.json`中新增命令：`dev:play`

        ```json
        "dev:play": "npm run build:file && cross-env NODE_ENV=development MODE=play  webpack-dev-server --config build/webpack.demo.js",
        ```

    2. 调整`webpack.demo.js`中的配置

        ```js
        const mode = process.env.MODE;
        const entrys = {
        	play: { docs: ['babel-polyfill', './examples/play.js'] },
        };

        const webpackConfig = {
        	mode: process.env.NODE_ENV,
        	entry: entrys[mode], // 设置项目入口
        };
        ```

    3. 在`examples/play.js`中，引入“测试组件”

    4. 启动项目：`npm run dev:play`

    5. 访问页面，即可查看“测试组件”

2. 方法 2：通过 ipdweb 官网的示例部分，引入组件并调试

    1. 修改`app.vue`中的鉴权

        ```vue
        <!--去掉checkUser鉴权-->
        <el-menu-item index="2" v-if="checkUser()">{{ titleLang.static }}</el-menu-item>
        ```

    2. 在官网示例的`examples\docs\zh-CN\xxx.md`文件中，引入相应的“测试组件 ”

    3. 启动项目：`npm run dev`

    4. 在导航的“静态组件”模块下，即可查看“测试组件”。

## 4. 注册组件&插件

### 4.1. 组件 vs 插件

1. 组件 (Component)：用来构成业务模块，它的目标是 App.vue。

2. 插件 (Plugin) ：用来增强技术栈的功能模块，即对 vue 功能的增强或补充，它的目标是 Vue 本身。（比如，将插件绑定到 vue 原型方法上，让每个组件中都可用调用该插件）。

### 4.2. 注册全局组件(Vue.component)

1. 使用`Vue.component(组件名、组件)`方法注册全局组件

    1. 说明：会放在`Vue.options.components`对象下

    2. 示例：

        ```js
        import Vue from 'vue';
        // 引入loading组件
        import Loading from './loading.vue';
        // 将loading注册为全局组件，在别的组件中通过<loading>标签使用Loading组件
        Vue.component('loading', Loading);
        ```

2. 使用 jsonp 注释全局组件

    1. 说明：会放在全局`window`下

3. 使用`lodash`自动注册全局组件/加载插件

    [参考链接](https://segmentfault.com/a/1190000019773184)

### 4.3. 注册插件（Vue.use）

[理解 vue.use](https://segmentfault.com/a/1190000021154285)

1. 方法：使用`Vue.use()`

    1. `Vue.use()`参数说明：接收一个参数，这个参数必须具有 install 方法。`Vue.use`函数内部会调用参数的`install`方法。

    2. 规则：如果插件没有被注册过，那么注册成功之后会给插件添加一个`installed`的属性值为`true`。`Vue.use`方法内部会检测插件的`installed`属性，从而避免重复注册插件。

2. 前置知识：`install()`

    1. 使用说明：将接收两个参数，第一个是参数是 Vue，第二个参数是配置项 options。
    2. 在`install`方法内部可以添加全局方法或者属性、全局指令、mixin 混入、添加实例方法、使用 Vue.component()注册组件等。

        ```js
        import Vue from 'vue';
        // 这个插件必须具有install方法
        const plugin = {
        	install(Vue, options) {
        		// 添加全局方法或者属性
        		Vue.myGlobMethod = function () {};
        		// 添加全局指令
        		Vue.directive();
        		// 添加混入
        		Vue.mixin();
        		// 添加实例方法
        		Vue.prototype.$xxx = function () {};
        		// 注册全局组件
        		Vue.component();
        	},
        };
        ```

### 4.4. .use 和.component 区别

1. 参数不同
2. .component 无法保证不重复注册

### 4.5. element 组件注册

1. 全局注册所有组件

    1. `main.js`文件中引入`element-ui`，通过`vue.use`注册全局组件

        ```js
        import ElementUI from 'element-ui';
        Vue.use(ElementUI);
        ```

    2. `Vue.use`调用`ElementUI`对象中的`install`方法（`src/index.js`中实现）

        1. 引入所有的组件，并汇总到`components`数组对象中
        2. install 中实现：遍历所有组件，并通过`vue.component()`注册为全局组件。

    ![image-20210804235712306](N-开发记录.assets/image-20210804235712306.png)

    ![image-20210804235555118](N-开发记录.assets/image-20210804235555118.png)

2. 全局注册某一个组件

    1. `main.js`文件中引入组件，通过`vue.use`注册全局组件

        ```js
        import { Aside } from 'element-ui';
        Vue.use(Aside); // 就会调用Aside组件对象中的install进行全局注册
        // or
        Vue.use(Aside.name, Aside);
        ```

    2. `package/Aside`组件定义

        ![image-20210805002922367](N-开发记录.assets/image-20210805002922367.png)

        ![image-20210805003047211](N-开发记录.assets/image-20210805003047211.png)

### 4.6. 通过 API 访问组件

[vue 封装一个可以通过 api 调用的组件](https://blog.csdn.net/yanzhi_2016/article/details/85614832)

## 5. 部署

### 5.1. 部署配置

1. 待了解：
    1. 静态文件处理
    2. 反向代理
    3. 负载均衡
    4. `alb,nginx`
2. 本地配置过程：
    1. 本地安装 `nginx`
    2. 配置本地 host
    3. 配置静态服务器
    4. 路由使用 history 模式
    5. 配置 nginx try-file（不配置无法刷新）
3. 学习资源
    1. [测试人员应该具备的开发知识](http://3ms.huawei.com/km/blogs/details/5538213?l=zh-cn)
    2. [Consul+Registrator+Consul-template 实现动态修改 nginx 配置文件](https://blog.51cto.com/zhaijunming5/1768321)
    3. [Vue Router history 模式的配置方法及其原理](https://segmentfault.com/a/1190000019391139)
    4. 本地：`common/deploy`

## 6. webpack

### 6.1. alias：取别名

1. 给安装包/路径取别名

    ```js
    // vue.config.js
    module.exports = {
    	chainWebpack: (config) => {
    		config.resolve.alias
    			.set('ipd-aui', '@insight-vue-ui/elementui') // 使用ipd-aui替代后者
    			.set('src', 'src'); // 路径别名
    	},
    };
    ```

    所有绝对路径会默认找 node

### 6.2. require.context：自动化导入

1. 作用：自动化、批量导入模块，替代import （前端工程自动化）
2. 语法：`require.context(directory,useSubDirectory,regExp);`

    1. 参数说明

        ```js
        // directory: 要查找的文件路径
        /**
         * directory: 要查找的文件路径
         * useSubdirectories: 是否查找子目录
         * regExp: 要匹配文件的正则
         */
        require.context(directory, useSubDirectory, regExp);
        ```

    2. 返回值：`webpackContext()`，为方法，包含：`__webpack_require__`就相当于`require`或者`import`,还有二个静态方法`keys`与`resolve`，一个`id`属性。

3. 使用示例：自动获取指定目录下所有模块名及模块

    ```js
    /** 文件目录结构
     * components
     * A
     * B
     * C
     */

    // 加载模块：components文件夹下，所有.js文件
    const coms = require.context('./components/', true, /\.js$/);

    // 查看webpackContext.keys()
    let map = {};
    for (let key of coms.keys()) {
    	map[key] = coms(key);
    }
    console.log(map);
    /**
     * ./A.js: Module{}
     * ./B.js: Module{}
     * ./C.js: Module{}
     */

    // 封装方法：处理key值，只保留文件名
    const importAll = (ctx) => {
    	let map = {};
    	for (let key of ctx.keys()) {
    		let resKey = key.split('/').shift();
    		map[resKey.join('.').replace(/\.js$/g, '')] = ctx(key);
    	}
    	return map;
    };

    // 使用
    importAll(require.context('./components/', true, /\.js$/));
    ```

4. [参考链接](https://zhuanlan.zhihu.com/p/59564277)，[参考链接2](https://www.jianshu.com/p/c894ea00dfec)

## 7. 工具

### 7.1. 命令行操作

1. 控制台定位到相应文件夹：打开文件夹》地址栏输入`cmd`，并回车

2. 删除文件夹：

    `/S` 除目录本身外，还将删除指定目录下的所有子目录和文件，用于删除目录树。
    `/Q` 安静模式，带 `/S` 删除目录树时不要求确认。

    如果路径含有空格，路径需要放在引号内。

    ```txt
    rmdir /s /q folder_name/“folder_path”
    ```

### 7.2. 键盘按键映射

1. [参考链接](http://www.360doc.com/content/18/0703/14/57256554_767366666.shtml)
2. 常用按键
    1. 8：退格 backspace



## 8. 路由

[指导书](https://router.vuejs.org/guide/essentials/named-views.html#nested-named-views)，[API](https://router.vuejs.org/api/)，[参考资料1](https://juejin.cn/post/6844903665388486664)

### 基本概念

1. `$router`：

   1. 路由实例，只写
   2. 功能：导航到不同url，可使用.push方法；路由传参。

2. `$route`：

   1. 当前路由对象，只读
   2. 功能：获取name,path,query,params,meta等，接收参数。

3. routes：配置router路由实例的routes API，用来配置多个route路由对象。


### 路由对象 属性介绍

1. **$route.path** 类型: `string` 字符串，对应当前路由的路径，总是解析为绝对路径，如 `"/foo/bar"`。
2. **$route .name** 当前路由的名称，如果有的话。**这里建议最好给每个路由对象命名,方便以后编程式导航.不过记住name必须唯一!**
3. **$route.params** 类型: `Object` 一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。
4. **$route.query** 类型: `Object` 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 `/foo?user=1`，则有 `$route.query.user == 1`，如果没有查询参数，则是个空对象。
5. **$route.hash** 类型: `string` 当前路由的 hash 值 (带 `#`) ，如果没有 hash 值，则为空字符串。
6. **$route.fullPath** 类型: `string` 完成解析后的 URL，包含查询参数和 hash 的完整路径。
7. **$route.matched** 类型: `Array` 一个数组，包含当前路由的所有嵌套路径片段的**路由记录** 。路由记录就是 `routes` 配置数组中的对象副本 (还有在 `children` 数组)。	 **$route.redirectedFrom** 如果存在重定向，即为重定向来源的路由的名字。

### 基本使用方法

1. 项目中安装vue-router包

   ```bash
   npm i vue-router -s
   ```

2. 配置路由实例router.js文件

   1. 引入必要插件及路由要用到的页面组件（推荐懒加载方式引入）
   2. 加载Router
   3. 配置路由实例

   ```js
   //第一步:引入必要的文件
   import Vue from 'vue';//加载全局组件时,都需要引入Vue
   import Router from 'vue-router';//引入vue-router
   import User from '@/components/user/User' //这里省略了.vue
   
   //第二步:加载Router
   Vue.use(Router);//加载全局组件Router
   
   //第三步:配置路由实例
   export default new Router({
   	//mode:'history', //路由模式:默认为hash,如果改为history,则需要后端进行配合
   	//base:'/',//基路径:默认值为'/'.如果整个单页应用在/app/下,base就应该设为'/app/'.一般可以写成__dirname,在webpack中配置.
   	routes:[{
   		path: '/user', 
   		name: 'user', //给路由命名,设置的name要唯一!
   		component: User//就是第一步import的组件
   		},{
   			//路由懒加载:单页面应用,首页时,加载内容时间过长.运用懒加载对页面组件进行划分,减少首页加载时间
   			path:'/Page',
   			name:'Page',
   			component:resolve => require(['@/components/Page'],resolve)
   			//此时component则不需要在第一步import
   		}]
   })
   ```

3. 在main.js中引入router.js并挂载到Vue实例

   ```js
   import router from './router'
   
   new Vue({
     el: '#app',
     router,// 挂在，不简写就是router:router,
     store,
     template: '<App/>',
     components: {
     App
     } })
   ```

4. 在组件内配置router-link和router-view

   1. router-link：映射路由.就是创建a标签来定义路由导航的链接(用户通过点击实现跳转).通过to属性指定目标地址.默认渲染成带有正确链接的<a>标签.
   2. router-view:就是在标签内渲染你路由匹配到的视图组件.router-view支持嵌套router-view,并且支持多个router-view分别渲染不同的component.详细[点击文档命名视图](https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fessentials%2Fnamed-views.html).
   3. **总结：2者在同一个页面中时，router-link设置路由跳转，router-view则根据路由显示对应的组件**

### 路由的两种模式

1. Hash
   1. 
2. history



### Url跳转

1. 通过<router-link :to>

   1.  在routes里配置对应的路由对象（也可以不配）

   2. 通过`to`设置跳转路径：

      ```vue
      <!--若在routes中配置了路由对象，可以直接使用path-->
      <router-link :to="/user">
        
      <!--若未配置，则在to中进行配置-->
      <router-link :to="{ name:'user',params:{paramId:'hello'},query:{queryId:'world'}}">helloWorld</router-link>
        
      <!--此处参数params会被忽略-->
      <router-link :to="{ path:'/user',params:{paramId:'hello'},query:{queryId:'world'}}">helloWorld</router-link>  
      ```

2. 通过“编程式导航”（见下文）

### 编程式导航

1. 定义：在vue组件内部通过`this.$router`访问路由实例,并通过`this.$router.push`**导航到不同的url**。它的作用是**和`<router-link :to>`是一样**的。

2. 使用场景：想在路由跳转前做点其他事情，例如权限验证等。

3. 方法1：`$router.push()`

   1. 正常使用方法：path+query搭配，name+params搭配
   2. **若name+query，没问题，query可以正常传参**
   3. **若path+params，有问题，params会被忽略**

   ```js
   // 字符串
   this.$router.push('home')
   
   // 对象
   this.$ruter.push({path:'home'})
   
   // 对象，命名路由
   this.$router.push({name:'user',params:{userId:2333}})
   
   // 带查询参数,变成/register?plan=private
   this.$router.push({path:'register',query:{plan:'private'}})
   ```

4. 方法2：`$router.replace`

   1. 功能：类似`$router.push`，可进行路由跳转。但**会替换掉history中的记录!**。
   2. 使用场景：跳转后，禁止用户使用浏览器进行后退操作。

5. 方法2：`$router.go(number)`

   1. 功能：在history记录中前进或后退多少步.类似`window.history.go(n)`。

### 路由传参（params和query）

1. params：

   1. 传参时：

      ```js
      this.$router.push({
          name: 'index' // 必须使用name
          params:{
            id:id
          }
        })
      ```

   2. 接收参数：

      ```js
      this.$route.params.id
      ```

   3. url的表现形式(url中没有参数)

      ```js
      /#/index
      ```

2. query：

   1. 传参时：

      ```js
      this.$router.push({
          path: '/index' // 必须使用path
          query:{
            id:id
          }
       })
      ```

   2. 接收参数：

      ```js
      this.$route.query.id
      ```

   3. url的表现形式(url中有参数)

      ```js
      #/index?id=1
      ```

3. params&query共同点

   1. 都是把参数放在url上，通过改变url进行的。这样就会造成参数和组件的高度耦合。

4. params&query不同点

   1. 传参时，引入路由方式不同，前者用name，后者用path
   2. 参数在url中是否展示，表现不同，前者无（相当于post请求），后者有（相当于get请求）
   3. 刷新页面，params里的数据会丢失，query里的数据不会丢失

5. 通过props进行路由组件传参

   ```js
    routes: [
       { path: '/', component: Hello }, // 没有传参  所以组件什么都拿不到
       { path: '/hello/:name', component: Hello, props: true }, //布尔模式: props 被设置为 true，此时route.params (即此处的name)将会被设置为组件属性。
       { path: '/static', component: Hello, props: { name: 'world' }}, // 对象模式: 此时就和params没什么关系了.此时的name将直接传给Hello组件.注意:此时的props需为静态!
       { path: '/dynamic/:years', component: Hello, props: dynamicPropsFn }, // 函数模式: 1,这个函数可以默认接受一个参数即当前路由对象.2,这个函数返回的是一个对象.3,在这个函数里你可以将静态值与路由相关值进行处理.
       { path: '/attrs', component: Hello, props: { name: 'attrs' }}
     ]
   ```



### 动态路由

### 嵌套路由&单组件多视图

### 重定向



### 路由懒加载

1. 实现原理：主要是靠**Vue 的异步组件**和 **Webpack 的代码分割功能**，轻松实现路由组件的懒加载。 

2. 代码：

   ```js
   // 路由配置，异步组件，(router.js)
   routes:[
         path:'/',
         name:'HelloWorld',
         component:resolve=>require(['@/component/HelloWorld'],resolve)
     ]
     
   // webpack配置代码分割(webpack.base.conf.js)
    output: {
    path: config.build.assetsRoot,
    filename: '[name].js',
    // 需要配置的地方
    chunkFilename: '[name].js',
    publicPath: process.env.NODE_ENV === 'production'
      ? config.build.assetsPublicPath
      : config.dev.assetsPublicPath
   } 
   ```

### 导航守卫

1. 定义：通俗点说就是路由钩子。
2. 作用：和生命周期钩子类似，在路由跳转过程进行操作控制.。

### 路由元信息

1. 定义：路由配置中的`meta`对象里的信息
2. 作用：隐性地传递信息，不会展示在url上

### 滚动行为

1. 方法：scrollBehavior
2. 作用：切换路由时，可以使页面滚动到你想要的某个地方；或者是保持之前滚动的位置。
3. 注意：
   1. 位置：针对整个组件而言，不包含组件里面的滚动条。
   2. 仅适用于`history`模式，因为用到了该模式的`pushState()`

## 9. 组件通信

### 9.1. 常用通信方式

1. 父子：`props`父》子属性，
2. 父子组件通信: `props`; `$parent` / `$children`; `provide` / `inject` ; `ref` ;  `$attrs` / `$listeners`；`emit()/ $on() `子》父事件。 (自封装（element）：broadcast 和 dispatch，实现子孙间事件触发)
3. 兄弟组件通信: `eventBus` ; 	vuex
4. 跨级通信:  `eventBus`；Vuex；`provide` / `inject` 、`$attrs` / `$listeners`

### 9.2. 属性透传 $attr

1. 功能：
2. 使用方法：
3. 参考资源：
   1. [使用方法](https://juejin.cn/post/6982727094937583647)
   2. [谨慎使用](https://juejin.cn/post/6864858225443864583)

## 10. JS事件循环：宏任务、微任务

相关材料：
[GUI渲染线程](https://www.jianshu.com/p/4f7ea28c924e)
[浏览器渲染机制](https://segmentfault.com/a/1190000014018604)
[浏览器渲染过程](https://www.cnblogs.com/haishen/p/9810356.html)
[浏览器渲染机制](https://blog.csdn.net/weixin_39308542/article/details/107197215)
[界面渲染原理](https://blog.csdn.net/qq_29582173/article/details/106613388)
[浏览器渲染原理](https://blog.csdn.net/csdnnews/article/details/95267307)
[setTimeout解决GUI渲染线程阻塞问题](https://blog.csdn.net/qq_26222859/article/details/77622222)
[Event Loop的规范和实现](https://zhuanlan.zhihu.com/p/33087629)
[微任务和宏任务的区别](https://blog.csdn.net/weixin_42554191/article/details/108722470)
[js 宏任务和微任务](https://www.cnblogs.com/wangziye/p/9566454.html)
[微任务、宏任务与Event-Loop](https://www.cnblogs.com/jiasm/p/9482443.html)
[]()

## 11. 组件开发实践

1. 编码规范自动检查：使用`haskey+eslint`

    ```js
    lint-staged:{

    },
    huskey:{
        hooks:{
    	   pre-commit:lint-staged // 提交前，检测编码规范
           commit-msg:commitlint -E HUSKY_GIT_PARAMS // 校验msg信息
    	   pre-push: // 提交时，执行测试用例
        }
    }

    ```

2. 自动化测试用例：angular

## 12. Vue 项目中使用 typescript

1. 测试后，发现有问题

## 13. 插槽

### 13.1. 13.1 分类

### 13.2. 13.2 父》子》...》孙

1. 思路：层层传递

2. 代码示例：（以具名插槽为例）

   ```html
   <!--父-->
   <div>
       我是父
       <template v-slot:child>父插入到孙中的内容:hello child</template>
   </div>
   
   <!--子，可层层嵌套多级，写法一致-->
   <div>
       我是子
       <template v-slot:child>
       <slot name='child'></slot>
       </template>
   </div>
   
   <!--孙:组件-->
   <div>
       我是孙
   	<slot name='child'></slot>
   </div>
   
   <!--
   最终输出：
   我是父
   我是子
   我是孙
   父插入到孙中的内容:hello child
   -->
   ```

## 14. vue原理

### 14.1. 14.1 响应式

1. vue不能检测到以下数组的变化
   1. 当你利用索引直接设置一个项时，例如：`vm.items[indexOfItem] = newValue`
   2. 当你修改数组的长度时，例如：`vm.items.length = newLength`
2. 解决方案：
   1. 对于第一种情况，可以使用：`Vue.set(example1.items, indexOfItem, newValue)`；
   2. 而对于第二种情况，可以使用 `vm.items.splice(newLength)`。

### 14.2. 计算属性中使用promise

1. 注意：computed计算变量的结果是直接取的function的返回值，不会考虑该function是否为异步，所以每次计算结果article都是一个Promise对象。
2. 建议：使用watch替代 （[解释](https://segmentfault.com/q/1010000012708169)）

‘

